"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../constants");
const Errors_1 = require("../Errors");
const selectPortMapping_1 = require("../utils/selectPortMapping");
const getRunMode_1 = require("../utils/getRunMode");
let runMode = null;
const getRunMode = () => {
    if (!runMode) {
        runMode = getRunMode_1.getRunMode();
    }
    return runMode;
};
const dockestConfig = process.env[constants_1.DOCKEST_ATTACH_TO_PROCESS];
if (!dockestConfig) {
    throw new Errors_1.DockestError('Config not attached to process: Not executed inside dockest context');
}
const config = JSON.parse(dockestConfig);
exports.getHostAddress = () => {
    if (getRunMode() !== 'docker-injected-host-socket') {
        return constants_1.DEFAULT_HOST_NAME;
    }
    return constants_1.DOCKEST_HOST_ADDRESS;
};
exports.resolveServiceAddress = (serviceName, targetPort) => {
    const service = config.services[serviceName];
    if (!service) {
        throw new Errors_1.DockestError(`Service "${serviceName}" does not exist`);
    }
    const portBinding = service.ports.map(selectPortMapping_1.selectPortMapping).find(portBinding => portBinding.target === targetPort);
    if (!portBinding) {
        throw new Errors_1.DockestError(`Service "${serviceName}" has no target port ${portBinding}`);
    }
    if (getRunMode() === 'docker-injected-host-socket') {
        return { host: serviceName, port: portBinding.target };
    }
    return { host: 'localhost', port: portBinding.published };
};
exports.getServiceAddress = (serviceName, targetPort) => {
    const record = exports.resolveServiceAddress(serviceName, targetPort);
    return `${record.host}:${record.port}`;
};
//# sourceMappingURL=index.js.map