"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const js_yaml_1 = require("js-yaml");
const io = __importStar(require("io-ts"));
const PathReporter_1 = require("io-ts/lib/PathReporter");
const Either = __importStar(require("fp-ts/lib/Either"));
const function_1 = require("fp-ts/lib/function");
const Errors_1 = require("../../Errors");
const Logger_1 = require("../../Logger");
const PortBinding = io.type({
    published: io.number,
    target: io.number,
});
const PortBindingFromString = new io.Type('PortBindingFromComposeString', PortBinding.is, (input, context) => {
    const match = input.match(/(\d*):(\d*)\/\w*/);
    return match
        ? io.success({
            target: parseInt(match[2], 10),
            published: parseInt(match[1], 10),
        })
        : io.failure(input, context, 'String did not match expected format.');
}, function_1.identity);
const PortBindingFromComposeFile = new io.Type('PortBindingFromComposeFile', PortBinding.is, (input, context) => function_1.pipe(io.string.is(input) ? PortBindingFromString.validate(input, context) : PortBinding.validate(input, context), Either.fold(err => io.failure(input, context, 'Could not decode the port mappings. This is most likely related to a breaking change in the docker-compose format.\n' +
    `Received: ${JSON.stringify(input)}\n` +
    err
        .filter(err => err.message)
        .map(err => `- ${err.message}`)
        .join('\n') +
    'Please report this issue on the dockest issue tracker: https://github.com/erikengervall/dockest/issues'), binding => io.success(binding))), function_1.identity);
const DockerComposeService = io.type({
    ports: io.array(PortBindingFromComposeFile),
});
const ComposeFile = io.type({
    version: io.string,
    services: io.record(io.string, DockerComposeService),
});
const handleDecodeError = (err) => {
    const lines = PathReporter_1.PathReporter.report(Either.left(err));
    throw new Errors_1.DockestError('Invalid schema. \n' + lines.map(line => `- ${line}`).join('\n'));
};
const decodeComposeFile = function_1.flow(ComposeFile.decode, Either.fold(handleDecodeError, function_1.identity));
const DOCKEST_COMPOSE_FILE_VERSION = '3.8';
exports.getParsedComposeFile = (mergedComposeFiles) => {
    const dockerComposeFile = function_1.pipe(mergedComposeFiles, js_yaml_1.safeLoad, decodeComposeFile);
    const versionNumber = parseFloat(dockerComposeFile.version);
    if (Math.trunc(versionNumber) < 3) {
        throw new Errors_1.DockestError(`Incompatible docker-compose file version. Please use version '3.x'`);
    }
    else if (dockerComposeFile.version !== DOCKEST_COMPOSE_FILE_VERSION) {
        Logger_1.Logger.warn(`You should upgrade to docker-compose file version '${DOCKEST_COMPOSE_FILE_VERSION}'. Dockest automatically uses that version.`);
        dockerComposeFile.version = DOCKEST_COMPOSE_FILE_VERSION;
    }
    return {
        dockerComposeFile,
    };
};
//# sourceMappingURL=getParsedComposeFile.js.map