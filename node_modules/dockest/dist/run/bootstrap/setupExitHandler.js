"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const Errors_1 = require("../../Errors");
const Logger_1 = require("../../Logger");
const teardownSingle_1 = require("../../utils/teardownSingle");
const LOG_PREFIX = '[Exit Handler]';
exports.setupExitHandler = async ({ dumpErrors, exitHandler: customExitHandler, mutables, mutables: { runners }, perfStart, }) => {
    let exitInProgress = false;
    const exitHandler = async (errorPayload) => {
        if (exitInProgress) {
            return;
        }
        // Ensure the exit handler is only invoced once
        exitInProgress = true;
        if (mutables.jestRanWithResult) {
            return;
        }
        if (errorPayload.reason instanceof Errors_1.BaseError) {
            const { payload: { error, runner, ...restPayload }, message, name, stack, } = errorPayload.reason;
            const logPayload = {
                data: {
                    name,
                    stack,
                },
            };
            runner && (logPayload.data.serviceName = runner.serviceName);
            runner && runner.containerId && (logPayload.data.containerId = runner.containerId);
            error && (logPayload.data.error = error);
            restPayload &&
                typeof restPayload === 'object' &&
                Object.keys(restPayload).length > 0 &&
                (logPayload.data.restPayload = restPayload);
            Logger_1.Logger.error(`${LOG_PREFIX} ${message}`, logPayload);
        }
        else {
            Logger_1.Logger.error(`${LOG_PREFIX} ${JSON.stringify(errorPayload, null, 2)}`);
        }
        if (customExitHandler && typeof customExitHandler === 'function') {
            await customExitHandler(errorPayload);
        }
        for (const runner of Object.values(runners)) {
            await teardownSingle_1.teardownSingle({ runner });
        }
        if (dumpErrors === true) {
            const dumpPath = `${process.cwd()}/dockest-error.json`;
            const dumpPayload = {
                errorPayload,
                timestamp: new Date(),
            };
            try {
                fs_1.default.writeFileSync(dumpPath, JSON.stringify(dumpPayload, null, 2));
            }
            catch (dumpError) {
                Logger_1.Logger.debug(`Failed to dump error to ${dumpPath}`, { data: { dumpError, dumpPayload } });
            }
        }
        Logger_1.Logger.measurePerformance(perfStart, { logPrefix: LOG_PREFIX });
        process.exit(errorPayload.code || 1);
    };
    // keeps the program from closing instantly
    process.stdin.resume(); // FIXME: causes "Jest has detected the following 1 open handle potentially keeping Jest from exiting:"
    // do something when app is closing
    process.on('exit', async (code) => exitHandler({ trap: 'exit', code }));
    // catches ctrl+c event
    process.on('SIGINT', async (signal) => exitHandler({ trap: 'SIGINT', signal }));
    // catches "kill pid" (for example: nodemon restart)
    process.on('SIGUSR1', async () => exitHandler({ trap: 'SIGUSR1' }));
    process.on('SIGUSR2', async () => exitHandler({ trap: 'SIGUSR2' }));
    // catches uncaught exceptions
    process.on('uncaughtException', async (error) => exitHandler({ trap: 'uncaughtException', error }));
    // catches unhandled promise rejections
    process.on('unhandledRejection', async (reason, promise) => exitHandler({ trap: 'unhandledRejection', reason, promise }));
};
//# sourceMappingURL=setupExitHandler.js.map