"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const net_1 = __importDefault(require("net"));
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const Errors_1 = require("../../Errors");
const selectPortMapping_1 = require("../../utils/selectPortMapping");
const LOG_PREFIX = '[Check Connection]';
const RETRY_COUNT = 10;
exports.acquireConnection = ({ host, port }) => new Promise((resolve, reject) => {
    let connected = false;
    let timeoutId = null;
    const netSocket = net_1.default
        .createConnection({ host, port })
        .on('connect', () => {
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        connected = true;
        netSocket.end();
        resolve();
    })
        .on('error', () => {
        connected = false;
    });
    timeoutId = setTimeout(() => !connected && reject(new Error('Timeout while acquiring connection')), 1000);
});
const checkPortConnection = ({ host, port, runner, acquireConnection, }) => rxjs_1.of({ host, port }).pipe(
// run check
operators_1.mergeMap(({ host, port }) => rxjs_1.from(acquireConnection({ host, port }))), 
// retry if check errors
operators_1.retryWhen(errors => {
    let retries = 0;
    return errors.pipe(operators_1.tap(() => {
        retries = retries + 1;
        runner.logger.debug(`${LOG_PREFIX} Timeout in ${RETRY_COUNT - retries}s (${host}:${port})`);
    }), operators_1.takeWhile(() => {
        if (retries < RETRY_COUNT) {
            return true;
        }
        throw new Errors_1.DockestError(`${LOG_PREFIX} Timed out`, { runner });
    }), operators_1.delay(1000));
}));
exports.createCheckConnection = ({ acquireConnection, }) => async ({ runner, runner: { dockerComposeFileService: { ports }, host: runnerHost, isBridgeNetworkMode, dockerEventStream$, }, }) => {
    const host = runnerHost || 'localhost';
    const portKey = isBridgeNetworkMode ? 'target' : 'published';
    if (!ports || ports.length === 0) {
        runner.logger.debug(`${LOG_PREFIX} Skip connection check as there are no ports exposed.`);
        return;
    }
    return rxjs_1.race(dockerEventStream$.pipe(operators_1.skipWhile(ev => ev.action !== 'die' && ev.action !== 'kill'), operators_1.map(event => {
        throw new Errors_1.DockestError('Container unexpectedly died.', { event });
    })), rxjs_1.of(...ports.map(selectPortMapping_1.selectPortMapping)).pipe(
    // concatMap -> run checks for each port in sequence
    operators_1.concatMap(({ [portKey]: port }) => checkPortConnection({ runner, host, port, acquireConnection })), 
    // we do not care about the single elements, we only want this stream to complete without errors.
    operators_1.ignoreElements())).toPromise();
};
exports.checkConnection = exports.createCheckConnection({ acquireConnection: exports.acquireConnection });
//# sourceMappingURL=checkConnection.js.map